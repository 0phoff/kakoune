Why Kakoune
===========

Why invest time into text editing
---------------------------------

While discussing with fellow developpers, I was a few times asked the
following question: We spend most of our time as developpers thinking, not
editing code, so why invest time into mastering a complicated code editor,
and why lose some cognitive resources on thinking about text edition instead
of about the real programming problem.

I think this point of view is misguided, for a few reasons:

* Despite their name, code editors are not only about edition, but also about
code navigation. Programming is a hard task partly due to the huge amount of
context we have to keep in mind, and being able to quickly navigate code helps
us refresh that context, by looking at definitions, implementations, comments.

* Although code edition itself is not the most important part of programming,
it still takes non negligible time to perform, and can be optimized by using
better tools. 

* Finally, a programming career spans a few decades, so investing a few weeks
to improve our editing and navigating speed is definitely worth it.

Why a modal text editor
-----------------------

What is modal text editing
~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that we have, hopefully, established that investing time into mastering  
text editing is worth it, lets focus on why I think modal text editors are the
way to go.

A modal text editor can be, as its name imply, in different modes. Depending on
the current mode, keys have a different effect: in *insert* mode most keys
effect would be to insert their character in the buffer, as in non-modal
editors, but in normal (default) mode keys have a different effect. For
example, `w` can move the cursor to the next word, `y` can yank (copy) the
current selection, `u` can undo, `g` followed by `f` can open the filename
under the cursor...

Some commands from *normal* mode would change the mode, for example `i` would
enter *insert* mode, from which the `<esc>` key would return to *normal* mode.

The first thing to realize that that non modal text editor are extremely biased
towards insertion. They make insertion easy (by making the default behaviour of
most keys to insert a character into the buffer) at the expense of making most
other operations suboptimal, by requiring hard to reach keys or modifiers (or,
even worse, moving your hand all the way to your mouse).

Insertion is an key part of text editing, and is worth optimizing, which is
the whole point of completion systems. But it is only a small part of text
editing, we spend a huge amount of our editing time navigating, moving code
around, copying, pasting and reformating.

Modal editors, on the other hand, and by modal here I focus mostly on the
vi lineage, default *normal* mode, which is tailored towards non insertion
operations, (copy, pasting, navigation), but still give access to a fully
blown *insert* mode a single keystroke away.

Modal editing as a text edition language
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Many vi users have any epiphany when they realize that vi does not just
provide a set of modes making various text editing shortcuts easier to type,
but actually provides a text editing language.

Commands are composable in order to express complex changes, `dw` in vi is
not just a shortcut to delete a word, it is the combination of a *verb* `d`
for delete, with an *object* `w` for word. There are more complex objects:
`ib` (inside block) refers to the content of the parenthesis surrounding
the cursor, so `yib` would yank (copy) the text inside the surround
parenthesis.

This language allows the programmer to express his intent much more closely
than in other editors; of course most editors can express "delete the word
after the next parenthesis", but more often than not, expressing that intent
is more cumbersome than simply doing an ad-hoc edition. Text editing as a
language changes that, by making clearly expressing your intent the fastest
and easiest way to do your edit.

This is a desirable property because a lot of text editing operations are
repetitive, but on only structurally similar text: the subject text are
different, but they follow the same structure. Being able to express the
text edition at the structural level allows for reusable commands, and make
the compute do the repetitive job.

Another often overlooked property of using text edition language is that
its fun. Programmers are problem solvers, we enjoy solving problems, and
we enjoy even more solving them with a clean and efficient solution. This
kind of text editor transform a dull and repetitive edition task into an
interesting puzzle to solve, and thats an engaging thing.

Think about it this way: Yes programming is about thinking, concentrating
on a design problem, or on a bug, understanding what needs to be done,
designing a solution, and the writing it. More often that not, once you get
to the writing phase, most of the thinking, problem solving, part is done,
now the remaining task is just editing the code.  Modal editors make this
phase both faster, and more fun.


Why Kakoune
-----------

Up to now, I have used vi as an example for modal text editor, mostly because
I expect most programmers have at least heard of it. However, I dont believe
vi and clones are the best modal text editor out there.

I have been working, for the last 5 years, on a new modal editor called
Kakoune. It first started as a reimplementation of Vim (the most popular vi
clone) whose source code is quite dated. But I soon realized that we could
improve a lot on vi editing model.

Improving on the editing model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

vi basic grammar is *verb* followed by *object*, its nice because it matches
well with the order we use in english, "delete word". On the other hand,
it does not match well with the nature of what we express: There is only a
handfull of *verbs* in text edition (*d*elete, *y*ank, *p*aste, *i*nsert...),
and they dont compose, contrarily to *objects* which can be arbitrarily
complex, and difficult to express. That means that errors are not handled
well. If you express your object wrongly with a delete verb, the wrong text
will get deleted, you will need to undo, and try again.

Kakoune grammar is *object* followed by *verb*, combined with instantaneous
feedback, that means you always see the current object (In Kakoune we call
that the selection) before you apply your change, which allows you to correct
errors on the go.

Kakoune tries hard to fix one of the big problems with the vi model: its
lack of interactivity. Because of the *verb* followed by *object* grammar,
vi changes are made in the dark, we dont see their effect until the whole
editing *sentence* is finished. `dtf` will delete to next *f*, if you then
realize that was one *f* before the one you targeted, you need to undo,
go back to your initial position, and try again with `d2tf`. In kakoune you
would to `tf` see immediatly that is not the *f* you were looking for, type
`Tf` to extend the selection until that *f*, then `d` to delete. At each
step you get visual feedback and have the opportunity to correct.

At lower level, the problem is that vi treats moving around and selecting an
object as two different things. Kakoune unifies that, moving *is* selecting.
`w` does not just go to the next word, it selects from current position to
the next word. By convention, capital commands tend to expand the selection,
so `W` would expand the current selection to the next word.

Multiple selections
~~~~~~~~~~~~~~~~~~~

Another particular feature of Kakoune is its support for, and emphasis
towards the use of multiple selections. Multiple selections in Kakoune
are not just one additional feature, it is the central way of interacting
with your text. For example there is no such thing as a "global replace" in
Kakoune. What you would do is select the whole buffer with the `%` command,
then select all matches for a regex in the current selections (that is the
whole buffer herer) with the `s` command, which prompts for a regex. You would
end up with one selection for each match of your regex and use the insert
mode to do your change. Globally replacing foo with bar would be done with
`%sfoo<ret>cbar<esc>` which is just the combination of basic building blocks.

Multiple selections provides us with a very powerfull to express structural
selection: we can subselect matches inside the current selections, keep
selections containing/not containing a match, split selections on a regex,
swap selections contents...

For example, convert from `snake_case_style` to `camelCaseStyle` can be done
by selecting the word (with `w` for example) then subselecting underscores
in the word with `s_<ret>`, deleting these with `d`, then upper casing the
selected characters with `~`. The inverse operation could be done by selecting
the word, then subselecting the upper case characters with `s[A-Z]<ret>`
lower casing them with ``` and then inserting an underscode before them with
`i_<esc>` This operation could be put in a macro, and would be reusable
easily to convert any identifier.

Another example would be parameter swapping, if you had `func(arg2, arg1);`
you could select the contents of the parenthesis with `<a-i>(`, split the
selection on comma with `S, <ret>`, and swap selection contents with `<a-'>`.

A better unix citizen
~~~~~~~~~~~~~~~~~~~~~


